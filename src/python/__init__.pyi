from typing import Callable, Iterable, TypeAlias, overload

from . import amd, blas, cholmod, info, klu, lapack, modeling, printing, solvers, umfpack
from ._types import Number
from .base import acos, asin, atan, conj, cos, exp, log, matrix, norm, sin, sparse, spdiag, spmatrix, sqrt, tan

MatrixLike: TypeAlias = matrix | spmatrix
ElementwiseResult: TypeAlias = Number | matrix | spmatrix

matrix_str: Callable[[MatrixLike], str]
matrix_repr: Callable[[MatrixLike], str]
spmatrix_str: Callable[[spmatrix], str]
spmatrix_repr: Callable[[spmatrix], str]


def copyright() -> None: ...
def license() -> None: ...
def normal(nrows: int, ncols: int = ..., mean: float = ..., std: float = ...) -> matrix: ...
def uniform(nrows: int, ncols: int = ..., a: float = ..., b: float = ...) -> matrix: ...
def weibull(nrows: int, ncols: int = ..., a: float = ..., b: float = ...) -> matrix: ...
def setseed(val: int = ...) -> None: ...
def getseed() -> int: ...

@overload
def max(x: Number) -> Number: ...
@overload
def max(x: matrix) -> Number: ...
@overload
def max(x: spmatrix) -> Number: ...
@overload
def max(x: Number, y: Number, *rest: Number) -> Number: ...
@overload
def max(x: matrix, y: Number | matrix, *rest: Number | matrix) -> matrix: ...
@overload
def max(x: Number, y: matrix, *rest: Number | matrix) -> matrix: ...
@overload
def max(x: spmatrix, y: Number | matrix | spmatrix, *rest: Number | matrix | spmatrix) -> matrix | spmatrix: ...
@overload
def max(x: Number, y: spmatrix, *rest: Number | matrix | spmatrix) -> matrix | spmatrix: ...
@overload
def max(values: Iterable[Number]) -> Number: ...
@overload
def max(values: Iterable[Number | matrix]) -> matrix: ...
@overload
def max(values: Iterable[Number | matrix | spmatrix]) -> matrix | spmatrix: ...

@overload
def min(x: Number) -> Number: ...
@overload
def min(x: matrix) -> Number: ...
@overload
def min(x: spmatrix) -> Number: ...
@overload
def min(x: Number, y: Number, *rest: Number) -> Number: ...
@overload
def min(x: matrix, y: Number | matrix, *rest: Number | matrix) -> matrix: ...
@overload
def min(x: Number, y: matrix, *rest: Number | matrix) -> matrix: ...
@overload
def min(x: spmatrix, y: Number | matrix | spmatrix, *rest: Number | matrix | spmatrix) -> matrix | spmatrix: ...
@overload
def min(x: Number, y: spmatrix, *rest: Number | matrix | spmatrix) -> matrix | spmatrix: ...
@overload
def min(values: Iterable[Number]) -> Number: ...
@overload
def min(values: Iterable[Number | matrix]) -> matrix: ...
@overload
def min(values: Iterable[Number | matrix | spmatrix]) -> matrix | spmatrix: ...

@overload
def mul(x: Number, y: Number, *rest: Number) -> Number: ...
@overload
def mul(x: matrix, y: Number | matrix, *rest: Number | matrix) -> matrix: ...
@overload
def mul(x: Number, y: matrix, *rest: Number | matrix) -> matrix: ...
@overload
def mul(x: spmatrix, y: Number | matrix | spmatrix, *rest: Number | matrix | spmatrix) -> matrix | spmatrix: ...
@overload
def mul(x: Number, y: spmatrix, *rest: Number | matrix | spmatrix) -> matrix | spmatrix: ...
@overload
def mul(values: Iterable[Number]) -> Number: ...
@overload
def mul(values: Iterable[Number | matrix]) -> matrix: ...
@overload
def mul(values: Iterable[Number | matrix | spmatrix]) -> matrix | spmatrix: ...

@overload
def div(x: Number, y: Number, *rest: Number) -> Number: ...
@overload
def div(x: matrix, y: Number | matrix, *rest: Number | matrix) -> matrix: ...
@overload
def div(x: Number, y: matrix, *rest: Number | matrix) -> matrix: ...
@overload
def div(x: spmatrix, y: Number | matrix | spmatrix, *rest: Number | matrix | spmatrix) -> matrix | spmatrix: ...
@overload
def div(x: Number, y: spmatrix, *rest: Number | matrix | spmatrix) -> matrix | spmatrix: ...
@overload
def div(values: Iterable[Number]) -> Number: ...
@overload
def div(values: Iterable[Number | matrix]) -> matrix: ...
@overload
def div(values: Iterable[Number | matrix | spmatrix]) -> matrix | spmatrix: ...

__version__: str
version_tuple: tuple[int, int, str]

__all__: list[str]
