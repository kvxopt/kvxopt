from typing import SupportsIndex, TypeAlias

from ._types import OptionValue
from .base import Number, matrix, spmatrix

ExpressionAtom: TypeAlias = Number | matrix | spmatrix


class expression:
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def value(self) -> matrix | None: ...
    def __getitem__(self, key: SupportsIndex | slice) -> "expression": ...
    def __add__(self, other: ExpressionAtom | "expression" | "variable") -> "expression": ...
    def __radd__(self, other: ExpressionAtom | "expression" | "variable") -> "expression": ...
    def __sub__(self, other: ExpressionAtom | "expression" | "variable") -> "expression": ...
    def __rsub__(self, other: ExpressionAtom | "expression" | "variable") -> "expression": ...
    def __mul__(self, other: ExpressionAtom | "expression" | "variable") -> "expression": ...
    def __rmul__(self, other: ExpressionAtom | "expression" | "variable") -> "expression": ...
    def __truediv__(self, other: ExpressionAtom | "expression" | "variable") -> "expression": ...
    def __neg__(self) -> "expression": ...
    def __pos__(self) -> "expression": ...
    def __abs__(self) -> "expression": ...
    def __eq__(self, other: ExpressionAtom | "expression" | "variable") -> "constraint": ...  # pyrefly: ignore[bad-override]
    def __le__(self, other: ExpressionAtom | "expression" | "variable") -> "constraint": ...
    def __ge__(self, other: ExpressionAtom | "expression" | "variable") -> "constraint": ...


class variable:
    name: str
    value: matrix | None

    def __init__(self, size: int = ..., name: str = ...) -> None: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __getitem__(self, key: SupportsIndex | slice) -> expression: ...
    def __add__(self, other: ExpressionAtom | expression | "variable") -> expression: ...
    def __radd__(self, other: ExpressionAtom | expression | "variable") -> expression: ...
    def __sub__(self, other: ExpressionAtom | expression | "variable") -> expression: ...
    def __rsub__(self, other: ExpressionAtom | expression | "variable") -> expression: ...
    def __mul__(self, other: ExpressionAtom | expression | "variable") -> expression: ...
    def __rmul__(self, other: ExpressionAtom | expression | "variable") -> expression: ...
    def __truediv__(self, other: ExpressionAtom | expression | "variable") -> expression: ...
    def __neg__(self) -> expression: ...
    def __pos__(self) -> expression: ...
    def __abs__(self) -> expression: ...
    def __eq__(self, other: ExpressionAtom | expression | "variable") -> "constraint": ...  # pyrefly: ignore[bad-override]
    def __le__(self, other: ExpressionAtom | expression | "variable") -> "constraint": ...
    def __ge__(self, other: ExpressionAtom | expression | "variable") -> "constraint": ...


class constraint:
    type: str
    value: matrix | None

    def __init__(self, f: expression, ctype: str = ...) -> None: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...


OpValue: TypeAlias = str | matrix | spmatrix | float | int | list[matrix] | dict[str, OptionValue] | None
OpResult: TypeAlias = dict[str, OpValue]


class op:
    objective: expression | None
    constraints: list[constraint]
    name: str
    status: str

    def __init__(self, objective: expression | None = ..., constraints: constraint | list[constraint] | None = ..., name: str = ...) -> None: ...
    def addconstraint(self, c: constraint) -> None: ...
    def delconstraint(self, c: constraint) -> None: ...
    def solve(self, format: str = ..., solver: str | None = ..., **kwargs: OptionValue) -> OpResult: ...
    def fromfile(self, filename: str) -> None: ...
    def tofile(self, filename: str) -> None: ...


def dot(x: ExpressionAtom | expression | variable, y: ExpressionAtom | expression | variable) -> expression: ...
def max(*s: ExpressionAtom | expression | variable) -> expression: ...
def min(*s: ExpressionAtom | expression | variable) -> expression: ...
def sum(s: expression | variable | matrix | spmatrix | list[expression | variable | matrix | spmatrix]) -> expression: ...


class varlist(list[variable]):
    pass
