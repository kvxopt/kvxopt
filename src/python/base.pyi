from typing import IO, Iterable, Iterator, Literal, Sequence, SupportsIndex, TypeAlias, overload

from ._types import Number, RealNumber

TypeCode: TypeAlias = Literal["i", "d", "z"]


class matrix:
    size: tuple[int, int]
    typecode: TypeCode
    H: "matrix"
    T: "matrix"

    def __init__(
        self,
        x: Number | Sequence[Number] | Sequence[Sequence[Number]] | "matrix" | "spmatrix" = ...,
        size: tuple[int, int] | None = ...,
        tc: TypeCode = ...,
    ) -> None: ...
    @classmethod
    def fromfile(cls, f: IO[bytes] | IO[str], size: tuple[int, int], tc: TypeCode = ...) -> "matrix": ...
    def tofile(self, f: IO[bytes] | IO[str]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Number]: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> Number: ...
    @overload
    def __getitem__(self, key: slice) -> "matrix": ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex | slice, SupportsIndex | slice]) -> Number | "matrix": ...
    def __setitem__(self, key: SupportsIndex | slice | tuple[SupportsIndex | slice, SupportsIndex | slice], value: Number | "matrix") -> None: ...
    def trans(self) -> "matrix": ...
    def ctrans(self) -> "matrix": ...
    def real(self) -> "matrix": ...
    def imag(self) -> "matrix": ...
    def __add__(self, other: Number | "matrix" | "spmatrix") -> "matrix": ...
    def __sub__(self, other: Number | "matrix" | "spmatrix") -> "matrix": ...
    def __mul__(self, other: Number | "matrix" | "spmatrix") -> "matrix": ...
    def __rmul__(self, other: Number | "matrix" | "spmatrix") -> "matrix": ...
    def __truediv__(self, other: Number | "matrix") -> "matrix": ...
    def __neg__(self) -> "matrix": ...
    def __pos__(self) -> "matrix": ...


IndexVector: TypeAlias = Sequence[SupportsIndex] | matrix
ValueVector: TypeAlias = Number | Sequence[Number] | matrix


class spmatrix:
    size: tuple[int, int]
    typecode: TypeCode
    I: list[int]
    J: list[int]
    V: list[Number]
    H: "spmatrix"
    T: "spmatrix"

    def __init__(
        self,
        V: ValueVector = ...,
        I: IndexVector = ...,
        J: IndexVector = ...,
        size: tuple[int, int] | None = ...,
        tc: TypeCode = ...,
    ) -> None: ...
    @property
    def CCS(self) -> tuple[list[int], list[int], list[Number]]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Number]: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> Number: ...
    @overload
    def __getitem__(self, key: slice) -> "spmatrix": ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex | slice, SupportsIndex | slice]) -> Number | "spmatrix" | matrix: ...
    def __setitem__(self, key: SupportsIndex | slice | tuple[SupportsIndex | slice, SupportsIndex | slice], value: Number | matrix | "spmatrix") -> None: ...
    def trans(self) -> "spmatrix": ...
    def ctrans(self) -> "spmatrix": ...
    def real(self) -> "spmatrix": ...
    def imag(self) -> "spmatrix": ...
    def ipset(self, values: ValueVector, rows: IndexVector, cols: IndexVector) -> None: ...
    def ipadd(self, values: ValueVector, rows: IndexVector, cols: IndexVector) -> None: ...
    def __add__(self, other: Number | matrix | "spmatrix") -> matrix | "spmatrix": ...
    def __sub__(self, other: Number | matrix | "spmatrix") -> matrix | "spmatrix": ...
    def __mul__(self, other: Number | matrix | "spmatrix") -> matrix | "spmatrix": ...
    def __rmul__(self, other: Number | matrix | "spmatrix") -> matrix | "spmatrix": ...
    def __truediv__(self, other: Number | matrix) -> matrix | "spmatrix": ...
    def __neg__(self) -> "spmatrix": ...
    def __pos__(self) -> "spmatrix": ...


MatrixLike: TypeAlias = matrix | spmatrix
ElementwiseArg: TypeAlias = Number | MatrixLike
ElementwiseResult: TypeAlias = Number | matrix | spmatrix


@overload
def acos(x: Number) -> Number: ...
@overload
def acos(x: MatrixLike) -> matrix: ...


@overload
def asin(x: Number) -> Number: ...
@overload
def asin(x: MatrixLike) -> matrix: ...


@overload
def atan(x: Number) -> Number: ...
@overload
def atan(x: MatrixLike) -> matrix: ...


@overload
def conj(x: Number) -> Number: ...
@overload
def conj(x: MatrixLike) -> matrix: ...


@overload
def cos(x: Number) -> Number: ...
@overload
def cos(x: MatrixLike) -> matrix: ...


@overload
def exp(x: Number) -> Number: ...
@overload
def exp(x: MatrixLike) -> matrix: ...


@overload
def log(x: Number) -> Number: ...
@overload
def log(x: MatrixLike) -> matrix: ...


@overload
def sin(x: Number) -> Number: ...
@overload
def sin(x: MatrixLike) -> matrix: ...


@overload
def sqrt(x: Number) -> Number: ...
@overload
def sqrt(x: MatrixLike) -> matrix: ...


@overload
def tan(x: Number) -> Number: ...
@overload
def tan(x: MatrixLike) -> matrix: ...


def axpy(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> None: ...
def div(*args: ElementwiseArg) -> ElementwiseResult: ...
def ediv(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> ElementwiseResult: ...
def emax(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> ElementwiseResult: ...
def emin(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> ElementwiseResult: ...
def emul(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> ElementwiseResult: ...
def gemm(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> None: ...
def gemv(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> None: ...
def getseed() -> int: ...
def mul(*args: ElementwiseArg) -> ElementwiseResult: ...
def norm(x: MatrixLike | Sequence[Number], p: RealNumber | str = ...) -> float: ...
def normal(nrows: int, ncols: int = ..., mean: float = ..., std: float = ...) -> matrix: ...

def setseed(val: int = ...) -> None: ...
@overload
def sparse(x: MatrixLike) -> spmatrix: ...
@overload
def sparse(x: Sequence[spmatrix]) -> spmatrix: ...
@overload
def sparse(x: Sequence[Sequence[spmatrix]]) -> spmatrix: ...
def spdiag(x: Sequence[Number] | matrix | spmatrix | Sequence[matrix | spmatrix]) -> spmatrix: ...
def symv(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> None: ...
def syrk(*args: ElementwiseArg, **kwargs: ElementwiseArg) -> None: ...
def uniform(nrows: int, ncols: int = ..., a: float = ..., b: float = ...) -> matrix: ...
