name: Linux build
on:
  push:
    branches: [ master, dev ]

jobs:
  build:
    runs-on: ubuntu-latest
    env:
        KVXOPT_BUILD_GSL: 1
        KVXOPT_BUILD_FFTW: 1
        KVXOPT_BUILD_GLPK: 1
        KVXOPT_BUILD_DSDP: 1
        KVXOPT_BUILD_OSQP: 1

    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.13']
        suite-sparse: [lib_suitesparse, src_suitesparse]


    steps:
      - uses: actions/checkout@v3
      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      - name: Load and set versions
        id: config
        shell: bash
        run: |
            source .ci/config/versions.env

            grep '^export ' .ci/config/versions.env | sed 's/export //' >> $GITHUB_ENV


      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools setuptools_scm build wheel pytest pytest-cov coveralls numpy pyrefly

      - name: Install libraries
        run: |
            sudo apt-get install libopenblas-dev libfftw3-dev libglpk-dev libdsdp-dev libgsl0-dev

      - name: Config suite-sparse library
        run:
            sudo apt-get install libsuitesparse-dev
        if: ${{ matrix.suite-sparse == 'lib_suitesparse' }}

      - name: Config suite-sparse source
        run: |
            wget https://github.com/DrTimothyAldenDavis/SuiteSparse/archive/v${SUITESPARSE_VERSION}.tar.gz
            echo "${SUITESPARSE_SHA256}  v${SUITESPARSE_VERSION}.tar.gz" > SuiteSparse.sha256
            shasum -a 256 -c SuiteSparse.sha256
            tar -xf v${SUITESPARSE_VERSION}.tar.gz
            echo "KVXOPT_SUITESPARSE_SRC_DIR=./SuiteSparse-${{ env.SUITESPARSE_VERSION }}" >> $GITHUB_ENV
        if: ${{ matrix.suite-sparse == 'src_suitesparse' }}

      - name: Get OSQP source and compile library
        run: |
            git clone --recursive https://github.com/oxfordcontrol/osqp.git
            cd osqp
            git checkout v${{ env.OSQP_VERSION }}
            git submodule sync --recursive
            git -c protocol.version=2 submodule update --init --force --depth=1 --recursive
            mkdir build
            cd build
            cmake -DCMAKE_INSTALL_PREFIX=/usr/local ..
            sudo cmake --build . --target install
            echo "KVXOPT_OSQP_LIB_DIR=/usr/local/lib" >> $GITHUB_ENV
            echo "KVXOPT_OSQP_INC_DIR=/usr/local/include/osqp" >> $GITHUB_ENV
            echo "LD_LIBRARY_PATH=/usr/local/lib" >> $GITHUB_ENV

      - name: Install
        run: |
          python setup.py build
          pip install .

      - name: Type Check
        run: |
          python - <<'PY'
          import ast
          import pathlib
          import subprocess
          import sys
          import tempfile

          import kvxopt

          repo_root = pathlib.Path.cwd()
          package_dir = pathlib.Path(kvxopt.__file__).resolve().parent
          installed_stubs = sorted(package_dir.glob("*.pyi"))
          typed_fixtures = sorted((repo_root / "tests" / "types").glob("*.py"))

          if not installed_stubs:
              print(f"error: no installed stubs found under {package_dir}", file=sys.stderr)
              raise SystemExit(2)
          if not typed_fixtures:
              print("error: no fixture files found under tests/types", file=sys.stderr)
              raise SystemExit(2)

          forbidden_names = {"Any", "object"}
          violations: list[tuple[pathlib.Path, int, str]] = []

          def iter_annotations(tree: ast.AST) -> list[ast.AST]:
              nodes: list[ast.AST] = []
              for node in ast.walk(tree):
                  if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                      if node.returns is not None:
                          nodes.append(node.returns)
                      for arg in node.args.posonlyargs + node.args.args + node.args.kwonlyargs:
                          if arg.annotation is not None:
                              nodes.append(arg.annotation)
                      if node.args.vararg and node.args.vararg.annotation is not None:
                          nodes.append(node.args.vararg.annotation)
                      if node.args.kwarg and node.args.kwarg.annotation is not None:
                          nodes.append(node.args.kwarg.annotation)
                  elif isinstance(node, ast.AnnAssign):
                      nodes.append(node.annotation)
                  elif hasattr(ast, "TypeAlias") and isinstance(node, ast.TypeAlias):
                      nodes.append(node.value)
              return nodes

          def forbidden_annotation(node: ast.AST) -> str | None:
              for child in ast.walk(node):
                  if isinstance(child, ast.Name) and child.id in forbidden_names:
                      return child.id
                  if (
                      isinstance(child, ast.Attribute)
                      and child.attr == "Any"
                      and isinstance(child.value, ast.Name)
                      and child.value.id == "typing"
                  ):
                      return "typing.Any"
              return None

          for path in [*installed_stubs, *typed_fixtures]:
              try:
                  tree = ast.parse(path.read_text(encoding="utf-8"), filename=str(path))
              except SyntaxError:
                  continue
              for annotation in iter_annotations(tree):
                  label = forbidden_annotation(annotation)
                  if label:
                      violations.append((path, getattr(annotation, "lineno", 1), label))

          if violations:
              print("error: forbidden annotations detected (Any/object are not allowed):", file=sys.stderr)
              for path, line, label in sorted(set(violations), key=lambda item: (str(item[0]), item[1], item[2])):
                  print(f"  - {path}:{line}: {label}", file=sys.stderr)
              raise SystemExit(1)

          def symlink_or_copy(src: pathlib.Path, dst: pathlib.Path) -> None:
              try:
                  dst.symlink_to(src)
              except OSError:
                  dst.write_text(src.read_text(encoding="utf-8"), encoding="utf-8")

          with tempfile.TemporaryDirectory(prefix="kvxopt-pyrefly-") as tmp:
              tmp_path = pathlib.Path(tmp)
              stub_pkg = tmp_path / "kvxopt"
              stub_pkg.mkdir(parents=True, exist_ok=True)

              for stub in installed_stubs:
                  symlink_or_copy(stub, stub_pkg / stub.name)

              command = [
                  "pyrefly",
                  "check",
                  "--config",
                  "pyproject.toml",
                  "--search-path",
                  str(tmp_path),
                  "--output-format",
                  "full-text",
                  *[str(path) for path in sorted(stub_pkg.glob("*.pyi"))],
                  *[str(path) for path in typed_fixtures],
              ]
              print("Running:", " ".join(command))
              raise SystemExit(subprocess.run(command, cwd=repo_root).returncode)
          PY

      - name: Test
        run: |
          echo ${KVXOPT_SUITESPARSE_SRC_DIR}
          python -c 'from kvxopt import blas,dsdp,lapack,glpk,osqp,fftw,gsl,cholmod,umfpack,klu'
          pytest --cov=kvxopt --cov-report=xml tests/

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          directory: ./coverage/reports/
          env_vars: OS,PYTHON
          files: ./coverage.xml
          fail_ci_if_error: true
          flags: unittests
          token: ${{ secrets.CODECOV_TOKEN }}
          slug: sanurielf/kvxopt
          verbose: true
